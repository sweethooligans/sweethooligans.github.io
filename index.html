<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Sweet Hooligans – Map Generator (Hi-Res Export)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; background: #0b0b0d; color: #fff;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    #map { width: 100%; height: 100vh; position: relative; background: #000; }
    .bar { position: absolute; left: 12px; right: 12px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap;
           background: rgba(24,24,27,.9); border: 1px solid rgba(255,255,255,.15); border-radius: 12px; padding: 8px 10px; z-index: 5; }
    #top { top: 12px; }
    #bottom { bottom: 12px; justify-content: center; }
    input[type="text"] { flex: 1 1 320px; max-width: 560px; background: rgba(255,255,255,.1); color: #fff; border: 1px solid rgba(255,255,255,.2);
                         border-radius: 10px; padding: 10px 12px; font-size: 16px; outline: none; }
    .btn { appearance: none; border: 1px solid rgba(255,255,255,.2); background: rgba(255,255,255,.12); color: #fff; border-radius: 10px;
           padding: 10px 12px; font-weight: 600; font-size: 14px; cursor: pointer; }
    .btn.primary { background: #4CAF50; }
    .tabs { display: flex; gap: 6px; }
    .tab { padding: 8px 10px; border-radius: 10px; border: 1px solid rgba(255,255,255,.2);
           background: rgba(255,255,255,.12); cursor: pointer; font-size: 13px; }
    .tab.active { background: #4CAF50; }
    .note { position: absolute; right: 12px; bottom: 70px; font-size: 12px; opacity: .85; background: rgba(24,24,27,.9);
            border: 1px solid rgba(255,255,255,.15); border-radius: 10px; padding: 6px 8px; z-index: 5; }
    select { background: rgba(255,255,255,.1); color: #fff; border: 1px solid rgba(255,255,255,.2);
             border-radius: 10px; padding: 8px 10px; font-size: 14px; outline: none; }
  </style>
</head>
<body>
  <div id="map" aria-label="Map"></div>

  <div id="top" class="bar">
    <form id="address-form" style="display:flex; gap:10px; flex-wrap:wrap; align-items:center; width:100%">
      <input id="address" type="text" placeholder="Enter address (e.g., 1600 Pennsylvania Ave NW, DC)" />
      <button class="btn primary" type="submit">Search</button>
      <div class="tabs" aria-label="Map Styles">
        <button class="tab active" data-style="style1" type="button">Style 1</button>
        <button class="tab" data-style="style2" type="button">Style 2</button>
        <button class="tab" data-style="style3" type="button">Style 3</button>
      </div>
    </form>
  </div>

  <div id="bottom" class="bar">
    <button class="btn" id="zoomOut" type="button">−</button>
    <span id="zoomLevel" style="min-width:3ch;text-align:center">12</span>
    <button class="btn" id="zoomIn" type="button">+</button>
    <button class="btn" id="centerMarker" type="button">Center to Marker</button>

    <!-- Choose export size (long side in pixels). 4096 is a great print-ready default. -->
    <label for="exportSize">PNG size:</label>
    <select id="exportSize">
      <option value="1280">1280 (quick)</option>
      <option value="2560">2560 (sharp)</option>
      <option value="3840">3840 (4K)</option>
      <option value="4096" selected>4096 (hi-res)</option>
      <option value="5120">5120 (ultra)</option>
    </select>

    <button class="btn primary" id="downloadBtn" type="button">Download PNG</button>
  </div>

  <div class="note">Tip: drag the ❤️ to fine-tune the location.</div>

  <script>
    // ===== CONFIG: your key + Map IDs =====
    const API_KEY = "AIzaSyBviIcXPutnW2Y49AxXduizoHy2_c9QEcI";
    const MAP_IDS = {
      style1: "49e651064b8ea8d6947bd49c",
      style2: "49e651064b8ea8d68e9a9d8b",
      style3: "49e651064b8ea8d625a41a78"
    };

    // Live marker icon (same image used on screen and in export)
    const HEART_ICON_URL = "https://upload.wikimedia.org/wikipedia/commons/thumb/f/f1/Heart_coraz%C3%B3n.svg/1920px-Heart_coraz%C3%B3n.svg.png";
    const HEART_SCREEN_PX = 34; // on-screen marker size in CSS px

    const DEFAULT_CENTER = { lat: 40.7128, lng: -74.0060 };
    const DEFAULT_ZOOM = 12;

    let map, marker, geocoder;
    let currentStyleKey = "style1";

    // --- Mercator helpers (base tile size = 256) ---
    const TILE_SIZE = 256;
    function worldSize(z){ return TILE_SIZE * Math.pow(2, z); }
    function lng2x(lng, z){ return (lng + 180) / 360 * worldSize(z); }
    function lat2y(lat, z){
      const s = Math.sin(lat * Math.PI / 180);
      const y = Math.log((1 + s) / (1 - s)) / 2;
      return (1 - y / Math.PI) / 2 * worldSize(z);
    }
    function x2lng(x, z){ return x / worldSize(z) * 360 - 180; }
    function y2lat(y, z){
      const n = Math.PI - 2 * Math.PI * y / worldSize(z);
      return 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
    }
    function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

    // Recreate map (reliable for style switching)
    function recreateMap(styleKey, center, zoom, markerPos){
      map = new google.maps.Map(document.getElementById("map"), {
        center: center || DEFAULT_CENTER,
        zoom: zoom ?? DEFAULT_ZOOM,
        mapId: MAP_IDS[styleKey],
        clickableIcons: false,
        gestureHandling: "greedy",
        mapTypeControl: false,
        streetViewControl: false,
        fullscreenControl: false
      });

      marker = new google.maps.Marker({
        position: markerPos || center || DEFAULT_CENTER,
        map,
        draggable: true,
        icon: { url: HEART_ICON_URL, scaledSize: new google.maps.Size(HEART_SCREEN_PX, HEART_SCREEN_PX) },
        title: "Drag me to adjust"
      });

      map.addListener("zoom_changed", () => {
        document.getElementById("zoomLevel").textContent = map.getZoom();
      });
    }

    // Build a single Static Maps request
    function buildStaticParams(centerLat, centerLng, zoom, sizeWBase, sizeHBase, mapId){
      const params = new URLSearchParams({
        center: `${centerLat},${centerLng}`,
        zoom: String(clamp(zoom, 0, 21)),
        size: `${Math.round(sizeWBase)}x${Math.round(sizeHBase)}`,  // base px (<=640)
        scale: "2",                                                // retina output (2x)
        format: "png",
        map_id: mapId,
        key: API_KEY
      });
      return `https://maps.googleapis.com/maps/api/staticmap?${params.toString()}`;
    }

    // High-res export: stitch multiple Static Maps tiles into one big canvas
    async function downloadHiResPNG(){
      const mapDiv = document.getElementById("map");
      const viewW = mapDiv.clientWidth;
      const viewH = mapDiv.clientHeight;
      const longSideTarget = parseInt(document.getElementById("exportSize").value, 10) || 4096;
      const aspect = viewH / viewW;

      // Final output px
      const outW = viewW >= viewH ? longSideTarget : Math.round(longSideTarget / aspect);
      const outH = viewW >= viewH ? Math.round(longSideTarget * aspect) : longSideTarget;

      // Static Maps constraints
      const scale = 2;                 // retina
      const baseMax = 640;             // size param limit per request (base px)
      const tileOutMax = baseMax * scale; // 1280 px per tile output

      // Number of tiles across each axis
      const tilesX = Math.ceil(outW / tileOutMax);
      const tilesY = Math.ceil(outH / tileOutMax);

      // Base-pixel sizes we need overall (for mercator math)
      const overallBaseW = outW / scale;
      const overallBaseH = outH / scale;

      // Precompute per-column/per-row base sizes (last tile may be smaller)
      const colBase = Array.from({length: tilesX}, (_, i) => {
        const full = (i < tilesX - 1) ? baseMax : (overallBaseW - baseMax * (tilesX - 1));
        return Math.max(1, Math.round(full));
      });
      const rowBase = Array.from({length: tilesY}, (_, j) => {
        const full = (j < tilesY - 1) ? baseMax : (overallBaseH - baseMax * (tilesY - 1));
        return Math.max(1, Math.round(full));
      });

      // Current map view info
      const z = clamp(map.getZoom(), 0, 21);
      const c = map.getCenter();
      const centerX = lng2x(c.lng(), z);
      const centerY = lat2y(c.lat(), z);

      // Stitch tiles
      const canvas = document.createElement("canvas");
      canvas.width = outW; canvas.height = outH;
      const ctx = canvas.getContext("2d");
      ctx.imageSmoothingEnabled = true;

      // Load heart image once (CORS-safe)
      const heartImg = await new Promise((res, rej)=>{
        const im = new Image();
        im.crossOrigin = "anonymous";
        im.onload = ()=> res(im);
        im.onerror = rej;
        im.src = HEART_ICON_URL;
      });

      let yBaseOffset = -overallBaseH/2;
      let drawY = 0;
      for (let j = 0; j < tilesY; j++){
        const hBase = rowBase[j];
        let xBaseOffset = -overallBaseW/2;
        let drawX = 0;

        for (let i = 0; i < tilesX; i++){
          const wBase = colBase[i];

          // Tile center (base px relative to whole image), then to world px
          const tileCenterX = centerX + (xBaseOffset + wBase/2);
          const tileCenterY = centerY + (yBaseOffset + hBase/2);
          const tileCenterLng = x2lng(tileCenterX, z);
          const tileCenterLat = y2lat(tileCenterY, z);

          const url = buildStaticParams(tileCenterLat, tileCenterLng, z, wBase, hBase, MAP_IDS[currentStyleKey]);
          const blob = await fetch(url).then(r => {
            if(!r.ok) throw new Error("Tile fetch failed");
            return r.blob();
          });

          // Draw tile
          const img = await new Promise((res, rej)=>{
            const im = new Image();
            im.onload = ()=> res(im);
            im.onerror = rej;
            im.src = URL.createObjectURL(blob);
          });

          const drawW = wBase * scale;      // to output px
          const drawH = hBase * scale;
          ctx.drawImage(img, drawX, drawY, drawW, drawH);

          // advance to next column
          xBaseOffset += wBase;
          drawX += drawW;
        }
        // next row
        yBaseOffset += hBase;
        drawY += hBase * scale;
      }

      // Overlay the same heart PNG, scaled to match what you see on screen
      const m = marker.getPosition();
      const mX = lng2x(m.lng(), z);
      const mY = lat2y(m.lat(), z);

      const dxBase = (mX - centerX);         // base px offset from center
      const dyBase = (mY - centerY);

      const pxX = canvas.width/2 + dxBase * scale;
      const pxY = canvas.height/2 + dyBase * scale;

      // Scale heart to preserve the same relative size as on screen
      const heartScale = canvas.width / viewW;          // how much wider the export is vs. screen
      const heartW = HEART_SCREEN_PX * heartScale;
      const heartH = HEART_SCREEN_PX * heartScale;

      // Anchor bottom-center like the live marker
      ctx.drawImage(heartImg, pxX - heartW/2, pxY - heartH, heartW, heartH);

      // Save
      const a = document.createElement("a");
      a.href = canvas.toDataURL("image/png");
      a.download = `sweet-hooligans-map-${currentStyleKey.toUpperCase()}-${outW}x${outH}.png`;
      document.body.appendChild(a); a.click(); a.remove();
    }

    // Google callback
    window.initMap = function(){
      geocoder = new google.maps.Geocoder();
      recreateMap(currentStyleKey);

      // Address search
      document.getElementById("address-form").addEventListener("submit", (e)=>{
        e.preventDefault();
        const addr = document.getElementById("address").value.trim();
        if (!addr) return;
        geocoder.geocode({ address: addr }, (results, status)=>{
          if (status === "OK" && results[0]){
            const loc = results[0].geometry.location;
            map.panTo(loc);
            marker.setPosition(loc);
            if (map.getZoom() < 14) map.setZoom(14);
          } else {
            alert("Address not found: " + status);
          }
        });
      });

      // Style tabs — reliably switch by recreating the map
      document.querySelectorAll(".tab").forEach(btn=>{
        btn.addEventListener("click", ()=>{
          if (btn.classList.contains("active")) return;
          document.querySelectorAll(".tab").forEach(b=>b.classList.remove("active"));
          btn.classList.add("active");

          currentStyleKey = btn.dataset.style;
          const c = map.getCenter(), z = map.getZoom(), mPos = marker.getPosition();
          recreateMap(currentStyleKey, c, z, mPos);
        });
      });

      // Zoom/center controls
      document.getElementById("zoomIn").addEventListener("click", ()=> map.setZoom(map.getZoom()+1));
      document.getElementById("zoomOut").addEventListener("click", ()=> map.setZoom(map.getZoom()-1));
      document.getElementById("centerMarker").addEventListener("click", ()=> map.panTo(marker.getPosition()));

      // Hi-res download
      document.getElementById("downloadBtn").addEventListener("click", downloadHiResPNG);

      // Keep zoom indicator correct
      document.getElementById("zoomLevel").textContent = map.getZoom();
      map.addListener("zoom_changed", ()=> document.getElementById("zoomLevel").textContent = map.getZoom());

      // Ensure proper sizing on viewport change
      window.addEventListener("resize", ()=> google.maps.event.trigger(map, "resize"));
    };
  </script>

  <!-- Load Google Maps after defining initMap -->
  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBviIcXPutnW2Y49AxXduizoHy2_c9QEcI&callback=initMap" async defer></script>
</body>
</html>
